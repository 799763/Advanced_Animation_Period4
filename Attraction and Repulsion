//  Bubble constructor function +++++++++++++++++++++++++++++
function Bubble(x, y, dx, dy, rad, clr){
    this.loc = new JSVector(x, y);
    this.vel = new JSVector(dx, dy);
    // this.x = x;
    // this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.rad = rad;///2;
    this.clr = clr;
    this.isOverlapping = false;
}

  //  placing methods in the prototype (every bubble shares functions)
Bubble.prototype.run = function(){
    this.checkEdges();
    this.checkOverlapping()
    this.update();
    this.render();
  }

// check if this bubble is overlapping any other bubble
Bubble.prototype.checkOverlapping = function(){
    this.isOverlapping = false;//  default color
    this.clr =  "rgba(255,255,255,255)"
    let b = game.bubbles;
    for(let i = 0; i < b.length; i++){ // for all the bubbles
       if(this !== b[i]){   // if not this bubble
         //let d = Math.sqrt((this.x-b[i].x)*(this.x-b[i].x) + (this.y-b[i].y)*(this.y-b[i].y));
         let d = this.loc.distance(b[i].loc);
         if(d < this.rad + b[i].rad){
            this.isOverlapping = true;
            this.clr =  "rgba(100,220,55,10)"
         }
       }
    }

  }

// draw the bubble on the canvas
Bubble.prototype.render = function(){
    let ctx = game.ctx;
    // color depends on whether this bubble overlaps any oher bubble
    // if(this.isOverlapping){
    //     ctx.strokeStyle = "rgba(255,255,255,255)"//this.clr;
    //     ctx.fillStyle = this.clr;
    //     ctx.beginPath();
    //     ctx.arc(this.loc.x,this.loc.y, this.rad, Math.PI*2, 0, false);
    //     ctx.stroke();
    //     ctx.fill();
    // }else{
    //     ctx.strokeStyle = this.clr;
    //     ctx.beginPath();
    //     ctx.arc(this.loc.x,this.loc.y, this.rad, Math.PI*2, 0, false);
    //     ctx.stroke();
    // }
    let Bub = game.bubbles;
    if(this == Bub[0]){
          ctx.fillStyle = "red";
          ctx.strokeStyle = "rgba(255,255,255,255)"//this.clr;
          ctx.beginPath();
          ctx.arc(this.loc.x,this.loc.y, this.rad, Math.PI*2, 0, false);
          ctx.stroke();
          ctx.fill();
    }else{
      ctx.fillStyle = "white";
          ctx.strokeStyle = "rgba(255,255,255,255)"//this.clr;
          ctx.beginPath();
          ctx.arc(this.loc.x,this.loc.y, this.rad, Math.PI*2, 0, false);
          ctx.stroke();
          ctx.fill();
    }

  }
//Bubbles update function
//+++++++++++++++++++++++++++++++++++++++++++++++

// Move the bubble in a random direction
// Bubble.prototype.update = function(){
//     if(!game.gamePaused){
//       this.vel.dx = Math.random()*6-3;
//       this.vel.dy = Math.random()*6-3;
//       this.loc.add(this.vel);
//     }
//   }

//+++++++++++++++++++++++++++++++++++++++++++++++

//Attraction update function
Bubble.prototype.update = function(){
    let Bub = game.bubbles;
    this.acc = new JSVector(0, 0);
    if(this != Bub[0]){
        let d = this.loc.distance(Bub[0].loc);
        if(d < 300){
            this.acc = JSVector.subGetNew(this.loc, Bub[0].loc);
            this.acc.normalize();
            this.acc.multiply(0.5);
        }
    }
    this.vel.add(this.acc);
    this.loc.add(this.vel);
}

//+++++++++++++++++++++++++++++++++++++++++++++++
// When a bubble hits an edge of the canvas, it wraps around to the opposite edge.
Bubble.prototype.checkEdges = function(){
    let canvas = game.canvas;
    if(this.loc.x > canvas.width)  this.loc.x = 0; // wrap around from right to left
    if(this.loc.x < 0)  this.loc.x = canvas.width; // wrap around from left to right
    if(this.loc.y > canvas.height)  this.loc.y = 0; // wrap around from bottom to top
    if(this.loc.y < 0)  this.loc.y = canvas.height; // wrap around from top to bottom
  }

function Game(){

    this.gamePaused = false;    // the game may be paused or not
    this.ga = new GameArea();   // create all the dom elements
    // get the canvas as a property of the game
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas
    this.canvas = document.getElementById('canvas');
    // get the context
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D
    this.ctx = this.canvas.getContext('2d'); // This is the context

    //   create the array of bubble objects
    this.bubbles = [];
    let numBubbles = 150;
    for(var i = 0; i < numBubbles; i++){
        var x, y, dx, dy, diam, clr, r, g, b;
        x = Math.random()*this.canvas.width;
        y = Math.random()*this.canvas.height;
        dx = Math.random()*6-3;
        dy = Math.random()*6-3;
        diam = 15;//Math.random()*20 + 10;
        r = 255;
        g = 255;
        b = 255;
        clr = "rgba(" + r + ", "+ g + ","+ b +")"
        this.bubbles.push(new Bubble(x, y, dx, dy, diam, clr)); // add new bubble to array
    }

    //  Add event handlers to all tile objects
    for(let i = 0; i < this.ga.tiles.length; i++){
        this.ga.tiles[i].addEventListener('mouseover', // mouseover is the name of an event
                                        function(){//  JavaScript has anonymous functions
                                          //  'this' is the listener target object: tile
                                          //  'this' does not refer to the game object
                                          this.style.backgroundColor = "#ac8fe3"
                                        },
                                        false);
        this.ga.tiles[i].addEventListener('mouseout', function(){
            this.style.backgroundColor = "#d5dee0"
          },false);
        this.ga.tiles[i].addEventListener('click', function(){
            game.gamePaused = !game.gamePaused;
            console.log("Mouse Clicked");
          },false);
    }

}//++++++++++++++++++++++  end Bubbles constructor

// function to run the game each animation cycle
Game.prototype.run = function(){
  if(!this.gamePaused){
    for(let i = 0; i < this.bubbles.length; i++){
      this.bubbles[i].run();    // run each bubble
   }
  }
}

// GameArea class to create all the DOM elements in code rather than html

function GameArea(){
    //  create Wrapper Div
    let wrapperDiv = document.createElement("div");
    wrapperDiv.id = "wrapperDiv";   // wrapperDiv gets its style from mystyles.css
    document.body.appendChild(wrapperDiv);  // child of the document body

    // create tileMenuDiv
    let tileMenuDiv = document.createElement("div");
    wrapperDiv.appendChild(tileMenuDiv) // tileMenuDiv is child of wrapperDiv
    tileMenuDiv.setAttribute("style", " background-color:#033c4a; width:1100px; height:100px;float:left;");

    // create canvasDiv
    let canvasDiv = document.createElement("div");
    wrapperDiv.appendChild(canvasDiv);  // canvasDiv is child of wrapperDiv
    canvasDiv.setAttribute("style", " background-color:pink; width:1100px; height:700px;float:left;");

    // create canvas
    let canvas =  document.createElement("canvas");
    canvas.id = 'canvas'; // gets its style from mystyles.css
    canvas.width = 1096;  // 800 - 4 for the border
    canvas.height = 696; // 700 - 4 for the border
    canvasDiv.appendChild(canvas);  // canvas is child of canvasDiv

    //  create tiles for tile menu
    //  tiles get their style from the .tile class in mystyles.css
    //  each tile has a child that is a text node
    this.tiles = [];    // array of tiles
    for(let i = 0; i < 6; i++){
       this.tiles[i] = document.createElement("div");
       tileMenuDiv.appendChild(this.tiles[i]);      // each tile is a child of the tileMenuDiv
       this.tiles[i].setAttribute("class", "tile"); // all tiles have the same class attribute
       // append a text node child to the tile
       this.tiles[i].appendChild(document.createTextNode("Tile " + (i + 1)));
       //this.t1Text.style.padding = "10px";
    }
}

<!DOCTYPE html>
<html>
  <head>
    <title>Dom Start Template</title>
    <link rel="stylesheet" type="text/css" href="mystyles.css">
    <script src="main.js"></script>
    <script src="gamearea.js"></script>
    <script src="game.js"></script>
    <script src="bubble.js"></script>
    <script src="jsvector.js"></script>
  </head>

  <body>
  </body>
</html>

// JSVector -- a Javascript 2D vector class
//  Fernando Rodriguez
//  Lab 9/25 - Vectors
// The class constructor
function JSVector(x = 0,y = 0){
        this.x = x;
        this.y = y;
}

// Set the magnitude of the vector,
// retaining the angle (direction).
JSVector.prototype.setMagnitude = function(mag){
    var dir = this.getDirection();
    this.x = mag * Math.cos(dir);
    this.y = mag * Math.sin(dir);
    return(this);
}

// Get the magnitude of the vector using pythagorean theorem
JSVector.prototype.getMagnitude = function(){
    return(Math.sqrt(this.x * this.x + this.y * this.y));
}

// Set the angle (direction) of the vector,
// retaining the magnitude.
JSVector.prototype.setDirection = function(angle){
    var mag = this.getMagnitude();
    this.x = mag * Math.cos(angle);
    this.y = mag * Math.sin(angle);
    return(this);
}

// Get the direction (angle) of the vector
JSVector.prototype.getDirection = function(){
    return(Math.atan2(y,x));
}

// Add another vector to this vector
JSVector.prototype.add = function(v2){
    this.x = this.x + v2.x;
    this.y = this.y + v2.y;
    return(this);
}

// Subtract another vector from this vector
JSVector.prototype.sub = function(v2){
    this.x = this.x - v2.x;
    this.y = this.y - v2.y;
    return(this);
}
//////
// Class method to return a new vector that is the sum of two vectors
JSVector.addGetNew = function(v1,v2){
    return(new JSVector(v1.x + v2.x, v1.y + v2.y));
}

// Class method to return a new vector that is the difference of two vectors
JSVector.subGetNew = function(v1,v2){
  return(new JSVector(v1.x - v2.x, v1.y - v2.y));
}

// Multiply this vector by a scalar
JSVector.prototype.multiply = function(scalar){
  this.x = this.x * scalar;
  this.y = this.y * scalar;
  return(this);
}

// Divide this vector by a scalar
JSVector.prototype.divide = function(scalar){
  this.x = this.x / scalar;
  this.y = this.y / scalar;
  return(this);
}

// Normalize this vector so that it has a magnitude of 1
JSVector.prototype.normalize = function(){
  this.setMagnitude(1);
  return(this);
}

// Limit the magnitude of this vector
JSVector.prototype.limit = function(lim){
  this.mag = this.getMagnitude();
  if(mag > lim){
    mag = lim;;
  }
  return(this);
}

// Get the distance between this vector and another one
JSVector.prototype.distance = function(v2){
  return ((v2.x + this.x) * (v2.x + this.x) + (v2.y + this.y) * (v2.y + this.y));
}

// Get square of the distance between this vector and another one
JSVector.prototype.distanceSquared = function(v2){
  return Math.sqrt((v2.x + this.x) * (v2.x + this.x) + (v2.y + this.y) * (v2.y + this.y));
}

// Rotate this vector by some number of radians
// using the rotation matrix |  cos   -sin  |
//                           |  sin   +cos  |
///////
JSVector.prototype.rotate = function(angle) {
    let x = this.x;
    let y = this.y;
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    this.x = x * cos - y * sin;
    this.y = x * sin + y * cos;
    return(this);
}

// Get the angle between this vector and another one
JSVector.prototype.angleBetween = function(v2){
  return(Math.abs(this.getDirection() - v2.getDirection()));
}

// Make a copy of this vector
JSVector.prototype.copy = function(){
  return(new JSVector(this.x, this.y));
}

// Override inherited toString() to describe this instance
JSVector.prototype.toString = function() {
  let x = this.x.toFixed(2);
  let y = this.y.toFixed(2);
  let mag = this.getMagnitude().toFixed(2);
  let dir = this.getDirection().toFixed(2);
  return("x: " + x + "y: "+ y + "Magnitude: " + mag + "Direction: " + dir);
}




var game;   // a single global object

window.onload = init;//  After the window has been loaded, go to init

function init(){
    game = new Game();  // global game
    animate();          // kick off the animation
}

//  animation loop called 60 fps
function animate(){
    // paint the canvas with mostly transparent black
  game.ctx.fillStyle = 'rgba(0,0,0,.05)'
  game.ctx.fillRect(0,0,game.canvas.width,game.canvas.height);
  game.run();    // run the game
  requestAnimationFrame(animate);
}



body {
   background-color: #013135;
   margin:0;
 }

#wrapperDiv {
 width:1100px;
 height:800px;
 margin:auto;
 margin-top: 20px;
 background-color:yellow;
 border: 5px solid black;
}

#canvas {
    border: solid black 2px;
    background-color: rgba(0,0,0, .95);
}


.tile{
  float:left;
  padding:20px;
  width:45px;
  height:35px;
  margin-left: 80px;
  margin-top: 10px;
  background-color: #d5dee0;
  border-radius: 100%;
  border: solid black 2px;
}
